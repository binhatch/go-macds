/*
Hella Gutmann - macsDS (Data Services) - API collection

This document contains all relevant APIs for diagnostics (incl. DTCs), repair & maintenance information (RMI) and vehicle identification.

API version: V20240702-130718
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package go-macds

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ServiceSchedulesAPIService ServiceSchedulesAPI service
type ServiceSchedulesAPIService service

type ApiServiceSchedules1mainRequest struct {
	ctx context.Context
	ApiService *ServiceSchedulesAPIService
	serviceSchedulesRequestDTO *ServiceSchedulesRequestDTO
}

// The request requires at least kType, regionCode, language.
func (r ApiServiceSchedules1mainRequest) ServiceSchedulesRequestDTO(serviceSchedulesRequestDTO ServiceSchedulesRequestDTO) ApiServiceSchedules1mainRequest {
	r.serviceSchedulesRequestDTO = &serviceSchedulesRequestDTO
	return r
}

func (r ApiServiceSchedules1mainRequest) Execute() ([]ServiceType, *http.Response, error) {
	return r.ApiService.ServiceSchedules1mainExecute(r)
}

/*
ServiceSchedules1main Post service schedules

Endpoint to get all available service types (such as fixed or variable service interval) and their associated services incl. expected labour times, interval details, instructions and more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServiceSchedules1mainRequest
*/
func (a *ServiceSchedulesAPIService) ServiceSchedules1main(ctx context.Context) ApiServiceSchedules1mainRequest {
	return ApiServiceSchedules1mainRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ServiceType
func (a *ServiceSchedulesAPIService) ServiceSchedules1mainExecute(r ApiServiceSchedules1mainRequest) ([]ServiceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ServiceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceSchedulesAPIService.ServiceSchedules1main")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/service-schedules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceSchedulesRequestDTO == nil {
		return localVarReturnValue, nil, reportError("serviceSchedulesRequestDTO is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceSchedulesRequestDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServiceSchedules2inspectionsRequest struct {
	ctx context.Context
	ApiService *ServiceSchedulesAPIService
	inspectionsRequestDTO *InspectionsRequestDTO
}

// For the request, it is required to specify the kType, language, regionCode as well as the desired serviceIds.
func (r ApiServiceSchedules2inspectionsRequest) InspectionsRequestDTO(inspectionsRequestDTO InspectionsRequestDTO) ApiServiceSchedules2inspectionsRequest {
	r.inspectionsRequestDTO = &inspectionsRequestDTO
	return r
}

func (r ApiServiceSchedules2inspectionsRequest) Execute() ([]SchemaCategory, *http.Response, error) {
	return r.ApiService.ServiceSchedules2inspectionsExecute(r)
}

/*
ServiceSchedules2inspections Post service schedules inspections

Endpoint to get detailed inspection steps, grouped by the sequence of operation in the repair shop, detailed labour times of the individual steps, potential components/spare parts (e.g. engine oil, ...), data inputs (e.g. tire pressure values), relevant technical data (e.g. engine oil specification) and helpful instructions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServiceSchedules2inspectionsRequest
*/
func (a *ServiceSchedulesAPIService) ServiceSchedules2inspections(ctx context.Context) ApiServiceSchedules2inspectionsRequest {
	return ApiServiceSchedules2inspectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SchemaCategory
func (a *ServiceSchedulesAPIService) ServiceSchedules2inspectionsExecute(r ApiServiceSchedules2inspectionsRequest) ([]SchemaCategory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SchemaCategory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceSchedulesAPIService.ServiceSchedules2inspections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/service-schedules/inspections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inspectionsRequestDTO == nil {
		return localVarReturnValue, nil, reportError("inspectionsRequestDTO is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inspectionsRequestDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
